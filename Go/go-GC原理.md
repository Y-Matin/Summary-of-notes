<!-- ### GO语言中年GC原理 -->

### GC机制触发条件
1.    在申请内存的时候，检查当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）
2.    每个两分钟GC一次。将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）
### 主GC线程中的GC流程
1. stop the world：等待所有的M休眠，此时所有的业务逻辑停止
2. 标记：分配gc任务，唤醒gomaxprocs个M(就是第一步休眠的M)，直到所有的M都做完，才结束；并且所有M再次进入休眠
3. 清理：有一个单独goroutine去清理已标记的内存对象块
4. start the world：设置gcwaiting=0，唤醒所有的M(不会超过P个数)

### 对GC流程的分布解释
#### 1.stop the world
1. 设置gcwaiting=1，这个在每一个G任务之前会检查一次这个状态，如是，则会将当前M休眠；
2. 如果这个M里面正在运行一个长时间的G任务，咋办呢，难道会等待这个G任务自己切换吗？这样的话可要等10ms啊，不能等！坚决不能等！  
所以会主动发出抢占标记，让当前G任务中断，再运行下一个G任务的时候，就会走到第1步 
3. 一直等待所有的M进入休眠，此时所有的业务逻辑代码都停止

#### 2. 标记
1. 根据gomaxprocs的个数，分配成 gomaxprocs个任务段；唤醒gomaxprocs-1个M来执行，（当前M也算一个）
2. 对于一个M，唤醒前设置他的helpGC标记，唤醒之后，这个M会立马判断这个标记，如果是标记状态，则开始做分配给自己的标记任务，如果先做完了，就会从别的M里面找一些来做
3. 等每一个M都做完，会在此进入休眠
#### 3. 清理
1. 通过设置参数，可以以一个单独的goroutine运行，这个功能是在1.3版本后增加的，这样的话直接下一步了，清理过程不是stw的
2. 也可以串行的在主GC线程执行：这样的话则清理过程也是stw的。
#### 4. start the world
1. 设置gcwaiting=0
2. 唤醒gomaxprocs个M继续做G任务（此时没有helpGC标记），业务逻辑代码开始
### 
