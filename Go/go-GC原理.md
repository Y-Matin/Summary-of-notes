### GO语言中年GC原理
<!-- TOC -->

- [GO语言中年GC原理](#go语言中年gc原理)
- [1. GC机制触发条件](#1-gc机制触发条件)
- [2. 主GC线程中的GC流程](#2-主gc线程中的gc流程)
- [3. 对GC流程的分布解释](#3-对gc流程的分布解释)
    - [3.1. 1.stop the world](#31-1stop-the-world)
    - [3.2. 标记](#32-标记)
    - [3.3. 清理](#33-清理)
    - [3.4. start the world](#34-start-the-world)
- [4.](#4)
- [5. gc原理:三色标记法](#5-gc原理三色标记法)
- [6. 写屏障](#6-写屏障)
    - [6.1. 造成引用对象丢失的场景：（同时满足条件1 和条件2）](#61-造成引用对象丢失的场景同时满足条件1-和条件2)
    - [6.2. 写屏障破坏两个条件之一即可](#62-写屏障破坏两个条件之一即可)
    - [6.3. 写屏障的分类](#63-写屏障的分类)

<!-- /TOC -->

```xml
发展

版本 ——发布时间——GC ——————————STW时间
v 1.1 ——2013/5 ——STW ——————————百ms-⼏百ms级别
v 1.3 ——2014/6 ——Mark STW, Sweep 并⾏ — 百ms级别
v 1.5 ——2015/8—— 三⾊标记法, 并发标记清除 -10ms级别
v 1.8 ——2017/2—— hybrid write barrier ————sub ms
```

### 1. GC机制触发条件
1.    在申请内存的时候，检查当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）
2.    每个两分钟GC一次。将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）
3.    手动触发 - runtime.GC()强制触发GC。
### 2. 主GC线程中的GC流程
1. stop the world：等待所有的M休眠，此时所有的业务逻辑停止
2. 标记：分配gc任务，唤醒gomaxprocs个M(就是第一步休眠的M)，直到所有的M都做完，才结束；并且所有M再次进入休眠
3. 清理：有一个单独goroutine去清理已标记的内存对象块
4. start the world：设置gcwaiting=0，唤醒所有的M(不会超过P个数)

### 3. 对GC流程的分布解释
#### 3.1. 1.stop the world
1. 设置gcwaiting=1，这个在每一个G任务之前会检查一次这个状态，如是，则会将当前M休眠；
2. 如果这个M里面正在运行一个长时间的G任务，咋办呢，难道会等待这个G任务自己切换吗？这样的话可要等10ms啊，不能等！坚决不能等！  
所以会主动发出抢占标记，让当前G任务中断，再运行下一个G任务的时候，就会走到第1步 
3. 一直等待所有的M进入休眠，此时所有的业务逻辑代码都停止

#### 3.2. 标记
1. 根据gomaxprocs的个数，分配成 gomaxprocs个任务段；唤醒gomaxprocs-1个M来执行，（当前M也算一个）
2. 对于一个M，唤醒前设置他的helpGC标记，唤醒之后，这个M会立马判断这个标记，如果是标记状态，则开始做分配给自己的标记任务，如果先做完了，就会从别的M里面找一些来做
3. 等每一个M都做完，会再次进入休眠
#### 3.3. 清理
1. 通过设置参数，可以以一个单独的goroutine运行，这个功能是在1.3版本后增加的，这样的话直接下一步了，清理过程不是stw的
2. 也可以串行的在主GC线程执行：这样的话则清理过程也是stw的。
#### 3.4. start the world
1. 设置gcwaiting=0
2. 唤醒gomaxprocs个M继续做G任务（此时没有helpGC标记），业务逻辑代码开始
### 4. 


### 5. gc原理:三色标记法
1. 首先把所有的对象都放到白色的集合中
2. 从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中
3. 遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中
4. 循环步骤3，直到灰色集合中没有对象
5. 步骤4结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收
![](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/go/go-gc.webp)


### 6. 写屏障
- 为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。
- 但是STW会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短STW的时间。

#### 6.1. 造成引用对象丢失的场景：（同时满足条件1 和条件2）
1. 一个黑色的节点A新增了指向白色节点C的引用
2. 并且白色节点C没有除了A之外的其他灰色节点的引用，或者存在但是在GC过程中被删除了
> 以上两个条件需要同时满足：满足条件1时说明节点A已扫描完毕，A指向C的引用无法再被扫描到；满足条件2时说明白色节点C无其他灰色节点的引用了，即扫描结束后会被忽略 
#### 6.2. 写屏障破坏两个条件之一即可
1. Dijistra写屏障
- 满足强三色不变性：黑色节点不允许引用白色节点
- 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色
2. Yuasa写屏障
- 满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏）
- 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色

#### 6.3. 写屏障的分类
**注意：由于栈上的操作需要保证性能，所以所有的写屏障均只针对堆上的对象。**
![](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/go/go-barrier.png)





