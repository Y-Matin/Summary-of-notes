### 并发编程系列（2）线程基础知识
<!-- TOC -->

- [并发编程系列（2）线程基础知识](#并发编程系列2线程基础知识)
- [1. 线程5中状态](#1-线程5中状态)
- [2. 创建线程方式：](#2-创建线程方式)
- [3. 线程挂起与恢复](#3-线程挂起与恢复)
    - [3.1. 挂起](#31-挂起)
    - [3.2. 挂起](#32-挂起)
    - [3.3. 如何挂起](#33-如何挂起)
    - [3.4. wait()与sleep()q区别](#34-wait与sleepq区别)
    - [3.5. 中断](#35-中断)
    - [3.6. 线程优先级](#36-线程优先级)

<!-- /TOC -->
### 1. 线程5中状态
```java
public enum State {
    //初始状态：新建了一个线程对象，但还未调用start()方法
    NEW,
    //运行： 线程是可运行状态，但可能在等待其他系统资源
    RUNNABLE,
    //阻塞：线程阻塞与synchronized锁，等待获取synchronized锁的状态
    BLOCKED,
    // 等待：Object.wait()；Object.join()
    WAITING,
    // 超时等待：Object.wait(long)
    TIMED_WAITING,
    // 终止：线程已经执行完毕
    TERMINATED;
    }
```
- 状态转换示意图：
  ![](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/thread_status.png)



### 2. 创建线程方式：
- 1. 继承Thread，并重写父类的run方法
- 2. 实现Runable接口，并实现run方法
> 实际开发采用第二种，实现接口的方式，因为java只允许单继承

### 3. 线程挂起与恢复
#### 3.1. 挂起
- 从“可执行状态”进入“非可自执行”状态下，在这个状态下CPU不会给线程分配时间片
- 对线程而言，就是处于一个暂停状态。

#### 3.2. 挂起
目的：避免资源的浪费

#### 3.3. 如何挂起
被废弃的方法
- 挂起：~~suspend()~~：不会释放线程所占有的资源，可能会导致死锁< 先唤醒，后挂起>
- 恢复：~~resume()~~：本身没有问题，但不能独立于suspend()方法存在  
 
可以使用的方法：
- wait() :   暂停执行、放弃已经获得的锁，进入等待状态
- notify()： 随机唤醒一个在等待锁的线程
- notifyAll()：唤醒所有在等待锁的线程，自行抢占CPU资源

#### 3.4. wait()与sleep()q区别
**wait()**
  1. 属于Object，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程
  2. wait方法释放了锁
  3. wait不需要捕获异常
  4. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用
**sleep()**
  1. 属于Thread类，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态
  2. sleep方法没有释放锁
  3. sleep必须捕获异常
  4. sleep可以在 任何地方使用
  
 #### 什么时候适合 挂起线程 
>现象：等待某些未就绪的资源   
      直到notify()方法被调用，被唤醒。
#### 3.5. 中断

1. ~~stop()~~~：方法已废弃，开发中不要使用，因为一调用，线程立即停止，导致后面逻辑未执行，最终导致数据不一致。
2. Thread.interrupt() ： 自定义一个标记，用来标志该线程是要被中断的。  
   可以通过Thread.isInterrupted()方法得到该标记。该标记可以作为是否继续执行的判断条件。
   
#### 3.6. 线程优先级

1. 线程的优先级告诉CPU该线程的重要程度，如果有大量线程被堵塞，都要等待执行，程序会尽可能地先运行优先级高的线程。优先级较低只是代表它获取时间片的机会小一些而已。
2. 线程优先级范围为1-10，优先级依次增加，Thread类中提供三个优先级，**MIN_PRIORITY(1)、NORM_PRIORITY(5)、MAX_PRIORITY(10)**，一般情况下推荐使用这几个常量。不用自行设置值，实际执行差异不大。
- 使用情况: 对线程的执行次数有要求，并且执行次数对程序结果无影响。
