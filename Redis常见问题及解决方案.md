<!-- # 1. Redis常见问题及解决方案 -->

<!-- TOC -->

- [1. Redis的数据类型，以及每种数据类型的使用场景](#1-redis的数据类型以及每种数据类型的使用场景)
- [2. Redis的持久化机制](#2-redis的持久化机制)
- [3. 常见缓存问题](#3-常见缓存问题)
    - [3.1. 缓存穿透](#31-缓存穿透)
    - [3.2. 缓存击穿](#32-缓存击穿)
    - [3.3. 缓存雪崩](#33-缓存雪崩)
    - [3.4. 缓存预热](#34-缓存预热)
    - [3.5. 缓存更新](#35-缓存更新)
    - [3.6. 缓存降级](#36-缓存降级)
- [4. Memcache与Redis区别都有哪些？](#4-memcache与redis区别都有哪些)
- [5. 单线程的Redis为什么这么快？](#5-单线程的redis为什么这么快)
- [6. Redis实现分布式锁](#6-redis实现分布式锁)
- [7. Redis有哪些适合的场景？](#7-redis有哪些适合的场景)

<!-- /TOC -->



## 1. Redis的数据类型，以及每种数据类型的使用场景
一共五种
- 1. String
> 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。
- 2. hash
>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
- 3. list
>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。
- 4. set
>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
- 5. sorted set
>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作

## 2. Redis的持久化机制
- 介绍:
 >Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件中保证数据持久化;当Redis重启后通过吧硬盘文件重新加载到内存，就能达到恢复数据的目的.
- 实现:
> 单独创建fork()子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入临时文件中，持久化的过程结束了，再用这临时文件替换上次的快照文件，然后子进程退出，内存释放。
- 实现方式：1. **RDB** ；2.**AOF** 
- **RDB**：
> RDB是Redis默认的持久化方式。按照一定的时间策略把内存以快照的形式保存到硬盘的二进制文件中。及Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件的save参数来定义快照的周期。*（快照可以是其所表示数据的一个副本，也可以是数据的一个复制品）*    

![](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925141429889-1694430603.png)
- 优缺点：
> **优势**：  
> 1. 整个Redis数据库的数据将被备份为一个文件，制定合理的备份策略，一旦系统出现灾难性故障，恢复比较容易。
> 2. 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。  

> **劣势**：  
> 1. 不能保证数据的高可用，因为系统一旦在定时持久化钱出现宕机现象，此前所有未备份的数据都会丢失。
> 2. 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至一秒钟。
- **AOF**：
> Redis会将每个收到的写命令通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。  

![](https://img2018.cnblogs.com/blog/1481291/201809/1481291-20180925141527592-2105439510.png)
> 速度快，数据可能不完整  

**当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。**

## 3. 常见缓存问题
### 3.1. 缓存穿透
- 原因：
> 缓存穿透是指一个查询数据的请求，在缓存中没有，在数据库中也没有，这样就无法件数据补充道缓存中。这样无论发起多少次请求都是直接查询数据库，如果有人利用这个漏洞，会加大数据库压力，严重科能导致宕机。
- 解决办法：
> 1. 常见的是采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。  
>2.  另一个简单粗暴地方法是将之前查询结果为空的key进行缓存，可以设置为5分钟失效。这样在5分钟内，再通过该key进行查询就可以直接在缓存中获取
### 3.2. 缓存击穿
- 原因：
> 缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
- 解决方案
> 1. 设置热点数据永远不过期。
  2. 加互斥锁.
### 3.3. 缓存雪崩
- 原因：
> 当缓存服务器重启或者大量缓存集中在某一个时间段失效，结果造成大量的请求去查询数据库，从而对数据库、cpu和内存造成巨大压力，严重会导致数据期宕机，最后使得整个系统崩溃！
- 解决办法：
> 1.将缓存失效时间分散开  
> 2. 考虑加锁<最多的解决方案>或者队列的方式，来保证不会有大量的线程对数据库一次性进行读写。


### 3.4. 缓存预热
- 概念：
> 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！
- 实现思路：
> 1. 直接写个缓存刷新页面，上线时手工操作下；
> 2. 数据量不大，可以再项目启动的时候自动进行加载；
> 3. 定时刷新缓存

### 3.5. 缓存更新
....
### 3.6. 缓存降级
....

## 4. Memcache与Redis区别都有哪些？
- 1. 存储方式Memecache把数据全部存储在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有持久化机制可以将数据被分到硬盘文件中。
- 2. 支持的数据类型不同：memcache所有的值均是简单的字符串，redis作为其替代者，支持更给丰富的数据类型，提供list，set，zset，hash。
- 3. 底层模型不同，与客户端通信协议不同。Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- 4. 存储最大value的空间不同：memcache只有1Mb，Redis最大可以达到512Mb。
- 5. redis的速度比memcache快很多。（redis是单线程，以及做了一些优化。）
- 6. Redis支持数据的备份，及master-slave模式的数据备份。

## 5. 单线程的Redis为什么这么快？
- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制

## 6. Redis实现分布式锁
- 原因：
> Redis为单进程单线程模式，采用队列的模式将并发访问变成串行访问，且对多客户端对Redis的连接并不存在竞争关系，


## 7. Redis有哪些适合的场景？

1）Session共享(单点登录)

2）页面缓存

3）队列

4）排行榜/计数器

5）发布/订阅