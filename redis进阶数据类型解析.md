## redis 三个高级数据类型解析
<!-- TOC -->

- [redis 三个高级数据类型解析](#redis-三个高级数据类型解析)
    - [1. Bitmaps 位图](#1-bitmaps-位图)
        - [1.1. 简介：](#11-简介)
        - [1.2. 操作方式](#12-操作方式)
        - [1.3. 命令](#13-命令)
        - [1.4. bitmaps一般的使用场景特点：](#14-bitmaps一般的使用场景特点)
        - [1.5. bitmaps 使用场景](#15-bitmaps-使用场景)
            - [1.5.1. 用户签到](#151-用户签到)
            - [1.5.2. 统计活跃用户（用户登录情况）](#152-统计活跃用户用户登录情况)
            - [1.5.3. 统计用户是否在线](#153-统计用户是否在线)
            - [1.5.4. 实现布隆过滤器](#154-实现布隆过滤器)
                - [1.5.4.1. 应用场景](#1541-应用场景)
                - [1.5.4.2. 特点：](#1542-特点)
    - [2. HyperLogLog  <不精确的去重计数方案>](#2-hyperloglog--不精确的去重计数方案)
        - [2.1. 简介：](#21-简介)
        - [2.2. 应用场景：](#22-应用场景)
        - [2.3. 特点 ：](#23-特点-)
        - [2.4. 优点 ：](#24-优点-)
        - [2.5. 缺点 ：](#25-缺点-)
    - [3. GEO](#3-geo)
        - [3.1. 简介](#31-简介)
    - [4. 总结](#4-总结)
        - [4.1. 计数器](#41-计数器)
    - [5. BitMap、HyperLogLog和布隆过滤器对比](#5-bitmaphyperloglog和布隆过滤器对比)
    - [6. 相同点：](#6-相同点)

<!-- /TOC -->

### 1. Bitmaps 位图
#### 1.1. 简介：
> bitmaps不是一个真实的数据结构。而是String类型上的一组面向bit操作的集合。由于strings是二进制安全的blob，并且它们的最大长度是512m，所以bitmaps能最大设置2^32(2^3*2^9*2^20)个不同的bit。
#### 1.2. 操作方式
1. 恒定时间的单个bit操作，例如把某个bit设置为0或者1。或者获取某bit的值。
2. 对一组bit的操作。例如给定范围内bit统计（例如人口统计）。
#### 1.3. 命令
- Bits设置和获取通过SETBIT 和GETBIT 命令，用法如下：
```xml
SETBIT key offset value     # 设置
GETBIT key offset           # 查询
```
- SETBIT命令第一个参数是位编号，第二个参数是这个位的值，只能是0或者1。如果bit地址超过当前string长度，会自动增大string。
- GETBIT命令指示返回指定位置bit的值。超过范围（寻址地址在目标key的string长度以外的位）的GETBIT总是返回0。三个操作bits组的命令如下：
    1. BITOP 执行两个不同string的位操作.，包括AND，OR，XOR和NOT.
    2. BITCOUNT 统计位的值为1的数量。
    3. BITPOS 寻址第一个为0或者1的bit的位置（寻址第一个为1的bit的位置：bitpos dupcheck 1； 寻址第一个为0的bit的位置：bitpos dupcheck 0）.
#### 1.4. bitmaps一般的使用场景特点：
1. 各种实时分析.
2. 存储与对象ID关联的节省空间并且高性能的布尔信息.
#### 1.5. bitmaps 使用场景
##### 1.5.1. 用户签到
> 背景：很多网站都提供了签到功能，并且需要**展示最近一个月的签到情况**，这种情况可以使用BitMap来实现。
- 实现方案：Key：（年份_用户id），offset = (今天是一年中的第几天)%(今年的天数)，
- 说明：表示在一年中，该用户的签到记录。
##### 1.5.2. 统计活跃用户（用户登录情况）
> 背景： 统计在一定时间窗口中，活跃的用户总数以及对应的活跃用户。
- 实现方案： Key: (日期) ，offset ： (用户id)。 如果当日活跃过，这该用户id对应的offset设置为1。
- 说明：表示在当天，活跃的用户记录
1. 统计连续两天活跃的用户总数：
```xml
bitop and dest1 20201009 20201010 
# 使用and 运算，取得两天活跃的用户offset,将结果放入dest1中 ；
# dest1 中值为1的offset，就是连续两天活跃用户的ID 
bitcount dest1
```
2. 统计20201009 ~ 20201010活跃过的用户：
```xml
bitop or dest2 20201009 20201010
```
##### 1.5.3. 统计用户是否在线
> 背景： 如果需要提供一个查询当前用户是否在线的接口，也可以考虑使用BitMap。即节约空间，效率又高，只需要一个key，然后用户id作为offset，如果在线就设置为1，不在线就设置为0.
##### 1.5.4. 实现布隆过滤器
> 什么是布隆过滤器？
![布隆过滤器介绍](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/布隆过滤器.png)
###### 1.5.4.1. 应用场景
1. 用户内容推荐，避免推荐已经推荐过的数据
2. 数据库查询优化：查询请求发出时，可以根据这个请求判定某个row存在不，如果布隆过滤器说不存在，则肯定不存在。如果说存在才去查询磁盘
3. 缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。
###### 1.5.4.2. 特点：
1. 当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。
2. 可以通过参数设置，达到无误差的程度。

### 2. HyperLogLog  <不精确的去重计数方案>
#### 2.1. 简介：
    - Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。
    - 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。
    - 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。
    - 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。

#### 2.2. 应用场景：
1. 比如做单网站今日UV统计的时候，把每个用户都加到hyperloglog里面，最后直接统计hpyerloglog的数量就好了
#### 2.3. 特点 ：
1. 不会记录元素的内容 
2. 单个key提供去重计数统计，但是会有误差
#### 2.4. 优点 ：
1. 12 KB 内存，就可以计算接近 2^64 个不同元素
#### 2.5. 缺点 ：
1. 标准误差是：0.81%


### 3. GEO
#### 3.1. 简介
> 这个功能可以将用户给定的地理位置（经度和纬度）信息储存起来，并对这些信息进行操作。


### 4. 总结
#### 4.1. 计数器
- 计数器可以分为：
    1. 简单计数器，用incr就可以实现；
    2. 有有效期的计数器，设置key的有效期就可以实现；
    3. 简单的去重计数器，用set实现；
    4. 高并发大数量去重计数器，用hll实现；


### 5. BitMap、HyperLogLog和布隆过滤器对比
### 6. 相同点：
    - 都是在大数据量下统计场景下使用

| 类型 | 经典案例 | 缺陷 | 误差分析| 内存分析|场景分析|
| :-----| :----- | :----- |:----- |:----- |:----- |
| BitMap | 统计用户一年的签到记录 | 1.注意setbit的偏移量，当偏移量很大时，可以会有较大耗时。2.数据稀疏，比如要存入(10,8887983,93452134)这三个数据，我们需要建立一个 99999999 长度的 BitMap ，但是实际上只存了3个数据，这时候就有很大的空间浪费。 |- | 假设要存储[0，99999999]共一亿个数据，每一个数据需要1个bit位，总共需要100000000bit，大概是12M。最大长度为2^32位|适用于不光记录总数还要具体的记录信息。且数据没有误差 |
| HyperLogLog | 统计网站的UV(用户总数数) | 1.计数有误差；2.不会储存输入元素本身，只能获取基数个数 |1.标准误差是0.81% | 1.每个HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。2.如果元素个数不多时，Redis会采用稀疏存储结构，其大小会少于12kb，采用密集存储结构，大小固定为12kb。3.相比 BitMap 1亿数据就需要 12M，如果 2^64个数据，粗略计算需要 1500 TB|适用于数据量大且需要计数、去重操作，只需要总数量，不需要具体数据的场景 |
| 布隆过滤器 |消息推荐：将用户没有看过的内容，进行推荐 | 1.误算率：随着数据量增加，误差逐渐增大。 2.很难删除数据 | 误判率可以使用公式计算，如果要求误判率越低，说西药的空间越大。假如要过滤1亿个数据，误判率为0.9%，所需空间约为117MB。可以使用bloom filter calculator计算[bloom-calculator](https://krisives.github.io/bloom-calculator/) |要求的误判率越低，占用空间越大，但和set相比空间占用小太多了。 |判断某一个值是不是已经存在。根据误差只存在于存在的情况，不存在的情况是精准的。可以用于推荐消息。这样推荐的消息 肯定是用户没有阅读过的 |

