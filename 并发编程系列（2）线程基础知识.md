###

### 线程5中状态
```java
public enum State {
    //初始状态：新建了一个线程对象，但还未调用start()方法
    NEW,
    //运行： 线程是可运行状态，但可能在等待其他系统资源
    RUNNABLE,
    //阻塞：线程阻塞与synchronized锁，等待获取synchronized锁的状态
    BLOCKED,
    // 等待：Object.wait()；Object.join()
    WAITING,
    // 超时等待：Object.wait(long)
    TIMED_WAITING,
    // 终止：线程已经执行完毕
    TERMINATED;
    }
```
- 状态转换示意图：
  ![](https://raw.githubusercontent.com/Y-Matin/Summary-of-notes/master/images/thread_status.png)



### 创建线程方式：
- 1. 继承Thread，并重写父类的run方法
- 2. 实现Runable接口，并实现run方法
> 实际开发采用第二种，实现接口的方式，因为java只允许单继承

### 线程挂起与恢复
#### 挂起
- 从“可执行状态”进入“非可自执行”状态下，在这个状态下CPU不会给线程分配时间片
- 对线程而言，就是处于一个暂停状态。

#### 挂起
目的：避免资源的浪费

#### 如何挂起
被废弃的方法
- 挂起：~~suspend()~~：不会释放线程所占有的资源，可能会导致死锁< 先唤醒，后挂起>
- 恢复：~~resume()~~：本身没有问题，但不能独立于suspend()方法存在  
 
可以使用的方法：
- wait() :   暂停执行、放弃已经获得的锁，进入等待状态
- notify()： 随机唤醒一个在等待锁的线程
- notifyAll()：唤醒所有在等待锁的线程，自行抢占CPU资源
  
 #### 什么时候适合 挂起线程 
>现象：等待某些未就绪的资源   
      直到notify()方法被调用，被唤醒。
#### 中断

1. ~~stop()~~~：方法已废弃，开发中不要使用，因为一调用，线程立即停止，导致后面逻辑未执行，最终导致数据不一致。
2. Thread.interrupt() ： 自定义一个标记，用来标志该线程是要被中断的。  
   可以通过Thread.isInterrupted()方法得到该标记。该标记可以作为是否继续执行的判断条件。
   
#### 线程优先级


