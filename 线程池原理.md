<!-- ## 线程池原理 -->

> 线程是稀缺资源，它的创建与销毁时比较重且耗资源的操作。而Java线程依赖于内核线程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法重用线程执行多个任务，线程池是一个线程缓存，负责多线程进行统一分配、调优与监控。
### 线程池优势：
1. 重用存在的线程，减少线程创建，销毁的开销，提高性能。
2. 提高响应速度。当任务到达时，可以直接中线程池中获取线程执行，无需先创建一个线程再执行。
3. 提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会减低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 线程池的创建方式
- ①. 通过Executors工具类共有5中方式创建线程池。
    1. Executors.newFixedThreadPool(5)  : 创建固定线程，一池5线程
    2. Executors.newWorkStealingPool()   ： 任务窃取，
    3. Executors.newSingleThreadExecutor()  ：创建单例线程，一池一线程
    4. Executors.newCachedThreadPool()   : 创建可缓存的线程池，
    5. Executors.newScheduledThreadPool() ： 创建定时任务的线程池
    > 不推荐使用上面的Executors工具类来创建线程，因为他们的线程队列是无界的，在并发量较高，或者线程执行时间过程，导致线程的等待队列的长度一直增加，最后可能会导致内存泄露（OOM）的问题。  
    线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。

    ![](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/无界队列.png)
- ②. 手动创建线程池   
    ThreadPoolExecutor构造函数参数解释：
    ```java
    /**
        * Creates a new {@code ThreadPoolExecutor} with the given initial
        * parameters.
        *
        * @param corePoolSize ：线程池中维护的核心线程数大小
        * @param maximumPoolSize ：线程池最大可执行的线程数的大小
        * @param keepAliveTime ：当线程池中的线程数大于核心线程数，该值表示临时线程的最大保留时间。
        * @param unit  ： 表明keepAliveTime的单位（秒、分、时）
        * @param workQueue ：当任务并发量大于了线程池的最大负载能力，则将任务放入阻塞队列，等线程池有空闲线程时，再将队列中的任务取出，让线程执行。
        * @param threadFactory ：线程池创建线程，是通过线程工厂来创建线程的。
        * @param handler ： 当等待队列达到设置上限后，后续任务无法添加进队列，这时会触发任务拒绝策略。<JDK 提供了四种拒绝策略。>
        * @throws IllegalArgumentException if one of the following holds:<br>
        *         {@code corePoolSize < 0}<br>
        *         {@code keepAliveTime < 0}<br>
        *         {@code maximumPoolSize <= 0}<br>
        *         {@code maximumPoolSize < corePoolSize}
        * @throws NullPointerException if {@code workQueue}
        *         or {@code threadFactory} or {@code handler} is null
        */
        public ThreadPoolExecutor(int corePoolSize,
                                int maximumPoolSize,
                                long keepAliveTime,
                                TimeUnit unit,
                                BlockingQueue<Runnable> workQueue,
                                ThreadFactory threadFactory,
                                RejectedExecutionHandler handler) {
            if (corePoolSize < 0 ||
                maximumPoolSize <= 0 ||
                maximumPoolSize < corePoolSize ||
                keepAliveTime < 0)
                throw new IllegalArgumentException();
            if (workQueue == null || threadFactory == null || handler == null)
                throw new NullPointerException();
            this.acc = System.getSecurityManager() == null ?
                    null :
                    AccessController.getContext();
            this.corePoolSize = corePoolSize;
            this.maximumPoolSize = maximumPoolSize;
            this.workQueue = workQueue;
            this.keepAliveTime = unit.toNanos(keepAliveTime);
            this.threadFactory = threadFactory;
            this.handler = handler;
        }
    ```
    - 1. AbortPolicy（中止策略）： 抛出异常
        ```java
        /**
            * A handler for rejected tasks that throws a
            * {@code RejectedExecutionException}.
            */
            public static class AbortPolicy implements RejectedExecutionHandler {
                /**
                * Creates an {@code AbortPolicy}.
                */
                public AbortPolicy() { }

                /**
                * Always throws RejectedExecutionException.
                */
                public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                    throw new RejectedExecutionException("Task " + r.toString() +
                                                        " rejected from " +
                                                        e.toString());
                }
            }
        ```
        1. 功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。
        2. 使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。
        3. ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列
        4. ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。
        5. 但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。
        6. 当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。
    - 2. DiscardPolicy（丢弃策略）：什么已不处理
        ```java
        /**
            * A handler for rejected tasks that silently discards the
            * rejected task.
            */
            public static class DiscardPolicy implements RejectedExecutionHandler {
                /**
                * Does nothing, which has the effect of discarding task r.
                */
                public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                }
            }
        ```
        1. 功能：直接静悄悄的丢弃这个任务，不触发任何动作。
        2. 使用场景：如果你提交的任务无关紧要，你就可以使用它。
        3. 因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。
    - 3. DiscardOldestPolicy（弃老策略）：抛弃最老的任务，执行新任务
        ```java
        /**
            * A handler for rejected tasks that discards the oldest unhandled
            * request and then retries {@code execute}, unless the executor
            * is shut down, in which case the task is discarded.
            */
            public static class DiscardOldestPolicy implements RejectedExecutionHandler {
                /**
                * Obtains and ignores the next task that the executor
                * would otherwise execute, if one is immediately available,
                * and then retries execution of task r, unless the executor
                * is shut down, in which case task r is instead discarded.
                */
                public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                    if (!e.isShutdown()) {
                        e.getQueue().poll();
                        e.execute(r);
                    }
                }
            }
        ```
        1. 功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行。
        2. 使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。
        3. 基于这个特性，能想到的场景就是，发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。
        4. 因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。
    - 4. CallerRunsPolicy（调用者运行策略）：任务交个提交人自己处理

        ```java
        /**
            * A handler for rejected tasks that runs the rejected task
            * directly in the calling thread of the {@code execute} method,
            * unless the executor has been shut down, in which case the task
            * is discarded.
            */
            public static class CallerRunsPolicy implements RejectedExecutionHandler {
                /**
                * Executes task r in the caller's thread, unless the executor
                * has been shut down, in which case the task is discarded.
                *
                * @param r the runnable task requested to be executed
                * @param e the executor attempting to execute this task
                */
                public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                    if (!e.isShutdown()) {
                        r.run();
                    }
                }
            }
        ```
        1. 功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。
        2. 使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。
        3. 因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。

### 线程池的五种状态
1. Running： 能处理已添加的任务，能接受新任务
2. Shutdown： 可以处理已经添加的任务，不能接受新任务
3. Stop: 不能处理已经添加的任务，不能接收新任务，并且中断正在处理的任务
4. Tiding： 所有的任务已经终止，ctl记录的任务数量为"0".<ctl: 负责记录线程池运行状态与活动线程数>
5. Terminated：线程池彻底终止，则线程池转化为terminated状态。
### 状态转换关系
![](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/ThreadPoolStatus.png)



```java```
```java```