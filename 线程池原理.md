<!-- ## 线程池原理 -->

> 线程是稀缺资源，它的创建与销毁时比较重且耗资源的操作。而Java线程依赖于内核线程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法重用线程执行多个任务，线程池是一个线程缓存，负责多线程进行统一分配、调优与监控。
### 线程池优势：
1. 重用存在的线程，减少线程创建，销毁的开销，提高性能。
2. 提高响应速度。当任务到达时，可以直接中线程池中获取线程执行，无需先创建一个线程再执行。
3. 提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会减低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 线程池的创建方式
- ①. 通过Executors工具类共有5中方式创建线程池。
    1. Executors.newFixedThreadPool(5)  : 创建固定线程，一池5线程
    2. Executors.newWorkStealingPool()   ： 任务窃取，
    3. Executors.newSingleThreadExecutor()  ：创建单例线程，一池一线程
    4. Executors.newCachedThreadPool()   : 创建可缓存的线程池，
    5. Executors.newScheduledThreadPool() ： 创建定时任务的线程池
    > 不推荐使用上面的Executors工具类来创建线程，因为他们的线程队列是无界的，在并发量较高，或者线程执行时间过程，导致线程的等待队列的长度一直增加，最后可能会导致内存泄露（OOM）的问题。  
    线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。

![](https://yds-01.coding.net/p/Summary-of-notes/d/Summary-of-notes/git/raw/master/images/无界队列.png)
- ②. 手动创建线程池   
    ThreadPoolExecutor构造函数参数解释：
    ```java
    /**
        * Creates a new {@code ThreadPoolExecutor} with the given initial
        * parameters.
        *
        * @param corePoolSize ：线程池中维护的核心线程数大小
        * @param maximumPoolSize ：线程池最大可执行的线程数的大小
        * @param keepAliveTime ：当线程池中的线程数大于核心线程数，该值表示临时线程的最大保留时间。
        * @param unit  ： 表明keepAliveTime的单位（秒、分、时）
        * @param workQueue ：当任务并发量大于了线程池的最大负载能力，则将任务放入阻塞队列，等线程池有空闲线程时，再将队列中的任务取出，让线程执行。
        * @param threadFactory ：线程池创建线程，是通过线程工厂来创建线程的。
        * @param handler ： 当等待队列达到设置上限后，后续任务无法添加进队列，这时会触发任务拒绝策略。<JDK 提供了四种拒绝策略。>
        * @throws IllegalArgumentException if one of the following holds:<br>
        *         {@code corePoolSize < 0}<br>
        *         {@code keepAliveTime < 0}<br>
        *         {@code maximumPoolSize <= 0}<br>
        *         {@code maximumPoolSize < corePoolSize}
        * @throws NullPointerException if {@code workQueue}
        *         or {@code threadFactory} or {@code handler} is null
        */
        public ThreadPoolExecutor(int corePoolSize,
                                int maximumPoolSize,
                                long keepAliveTime,
                                TimeUnit unit,
                                BlockingQueue<Runnable> workQueue,
                                ThreadFactory threadFactory,
                                RejectedExecutionHandler handler) {
            if (corePoolSize < 0 ||
                maximumPoolSize <= 0 ||
                maximumPoolSize < corePoolSize ||
                keepAliveTime < 0)
                throw new IllegalArgumentException();
            if (workQueue == null || threadFactory == null || handler == null)
                throw new NullPointerException();
            this.acc = System.getSecurityManager() == null ?
                    null :
                    AccessController.getContext();
            this.corePoolSize = corePoolSize;
            this.maximumPoolSize = maximumPoolSize;
            this.workQueue = workQueue;
            this.keepAliveTime = unit.toNanos(keepAliveTime);
            this.threadFactory = threadFactory;
            this.handler = handler;
        }
    ```
    - 1.AbortPolicy（中止策略）： 
        ```java
        /**
            * A handler for rejected tasks that throws a
            * {@code RejectedExecutionException}.
            */
            public static class AbortPolicy implements RejectedExecutionHandler {
                /**
                * Creates an {@code AbortPolicy}.
                */
                public AbortPolicy() { }

                /**
                * Always throws RejectedExecutionException.
                *
                * @param r the runnable task requested to be executed
                * @param e the executor attempting to execute this task
                * @throws RejectedExecutionException always
                */
                public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                    throw new RejectedExecutionException("Task " + r.toString() +
                                                        " rejected from " +
                                                        e.toString());
                }
            }
        ```
        1. 功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程。
        2. 使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。
        3. ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列
        4. ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。
        5. 但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。
        6. 当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。

```java```
```java```
```java```
### 线程池的五种状态
1. Running： 能处理已添加的任务，能接受新任务
2. Shutdown： 可以处理已经添加的任务，不能接受新任务
3. Stop: 不能处理已经添加的任务，不能接收新任务，并且中断正在处理的任务
4. Tiding： 所有的任务已经终止，ctl记录的任务数量为"0".<ctl: 负责记录线程池运行状态与活动线程数>
5. Terminated：线程池彻底终止，则线程池转化为terminated状态。



```java```
```java```